/**
 * CSS Selector Generator
 *
 * Generates unique CSS selectors for DOM elements.
 * Used by the state mapping feature to identify trigger elements.
 *
 * Priority order:
 * 1. ID selector (most stable)
 * 2. Data attribute (data-testid, data-cy, etc.)
 * 3. Unique class combination
 * 4. Structural path (fallback)
 */

import type { SelectedElementInfo } from '@/types/state-mapping'

/**
 * Generate a unique CSS selector for an element
 */
export function generateSelector(element: HTMLElement): string {
  // 1. Try ID selector (most stable)
  if (element.id && isValidId(element.id)) {
    const selector = `#${CSS.escape(element.id)}`
    if (isUniqueSelector(selector)) {
      return selector
    }
  }

  // 2. Try data-testid or similar test attributes
  const testId =
    element.getAttribute('data-testid') ||
    element.getAttribute('data-test-id') ||
    element.getAttribute('data-cy') ||
    element.getAttribute('data-test')

  if (testId) {
    const attrName = element.hasAttribute('data-testid')
      ? 'data-testid'
      : element.hasAttribute('data-test-id')
        ? 'data-test-id'
        : element.hasAttribute('data-cy')
          ? 'data-cy'
          : 'data-test'
    const selector = `[${attrName}="${CSS.escape(testId)}"]`
    if (isUniqueSelector(selector)) {
      return selector
    }
  }

  // 3. Try unique class combination
  const uniqueClassSelector = findUniqueClassSelector(element)
  if (uniqueClassSelector) {
    return uniqueClassSelector
  }

  // 4. Try tag + unique class combination
  const tagClassSelector = findTagClassSelector(element)
  if (tagClassSelector) {
    return tagClassSelector
  }

  // 5. Fall back to structural path
  return generateStructuralPath(element)
}

/**
 * Generate a human-readable label for an element
 */
export function generateSelectorLabel(element: HTMLElement): string {
  const tag = element.tagName.toLowerCase()

  // Include ID if present
  if (element.id) {
    return `${tag}#${element.id}`
  }

  // Include first 2-3 meaningful classes
  const classes = getSignificantClasses(element)
  if (classes.length > 0) {
    const classString = classes.slice(0, 3).join('.')
    return `${tag}.${classString}`
  }

  // Just tag name
  return tag
}

/**
 * Get full element info for display
 */
export function getSelectedElementInfo(element: HTMLElement): SelectedElementInfo {
  const rect = element.getBoundingClientRect()

  return {
    selector: generateSelector(element),
    label: generateSelectorLabel(element),
    tagName: element.tagName.toLowerCase(),
    className: element.className,
    id: element.id || null,
    textContent: getTextPreview(element),
    rect: {
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
    },
  }
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Check if an ID is valid (not auto-generated)
 */
function isValidId(id: string): boolean {
  // Skip IDs that look auto-generated
  const autoGeneratedPatterns = [
    /^:r[0-9a-z]+:$/, // React auto-generated
    /^[0-9a-f]{8}-[0-9a-f]{4}/, // UUID-like
    /^[0-9]+$/, // Just numbers
    /^__/, // Double underscore prefix
    /^ember\d+/, // Ember auto-generated
    /^ext-/, // Extension-generated
  ]

  return !autoGeneratedPatterns.some((pattern) => pattern.test(id))
}

/**
 * Check if a selector uniquely identifies one element
 */
function isUniqueSelector(selector: string): boolean {
  try {
    const matches = document.querySelectorAll(selector)
    return matches.length === 1
  } catch {
    return false
  }
}

/**
 * Get significant (non-utility) classes from an element
 */
function getSignificantClasses(element: HTMLElement): string[] {
  if (!element.className || typeof element.className !== 'string') {
    return []
  }

  const classes = element.className.split(/\s+/).filter(Boolean)

  // Filter out common utility classes and auto-generated ones
  const utilityPatterns = [
    /^(w|h|p|m|px|py|mx|my|pt|pb|pl|pr|mt|mb|ml|mr)-/, // Tailwind spacing
    /^(flex|grid|block|inline|hidden)$/, // Display utilities
    /^(text|bg|border|rounded)-/, // Tailwind design tokens
    /^(sm|md|lg|xl|2xl):/, // Responsive prefixes
    /^hover:/, // State prefixes
    /^focus:/, // State prefixes
    /^active:/, // State prefixes
    /^[a-z]{1,3}[0-9]+$/, // Short + number (likely generated)
    /^css-/, // CSS-in-JS generated
    /^sc-/, // Styled components
    /^emotion-/, // Emotion generated
  ]

  return classes.filter((cls) => !utilityPatterns.some((p) => p.test(cls)))
}

/**
 * Find a unique selector using class combinations
 */
function findUniqueClassSelector(element: HTMLElement): string | null {
  const classes = getSignificantClasses(element)
  if (classes.length === 0) return null

  // Try single class first
  for (const cls of classes) {
    const selector = `.${CSS.escape(cls)}`
    if (isUniqueSelector(selector)) {
      return selector
    }
  }

  // Try combinations of 2 classes
  if (classes.length >= 2) {
    for (let i = 0; i < classes.length - 1; i++) {
      for (let j = i + 1; j < classes.length; j++) {
        const selector = `.${CSS.escape(classes[i])}.${CSS.escape(classes[j])}`
        if (isUniqueSelector(selector)) {
          return selector
        }
      }
    }
  }

  // Try combinations of 3 classes
  if (classes.length >= 3) {
    for (let i = 0; i < classes.length - 2; i++) {
      for (let j = i + 1; j < classes.length - 1; j++) {
        for (let k = j + 1; k < classes.length; k++) {
          const selector = `.${CSS.escape(classes[i])}.${CSS.escape(classes[j])}.${CSS.escape(classes[k])}`
          if (isUniqueSelector(selector)) {
            return selector
          }
        }
      }
    }
  }

  return null
}

/**
 * Find a unique selector using tag + classes
 */
function findTagClassSelector(element: HTMLElement): string | null {
  const tag = element.tagName.toLowerCase()
  const classes = getSignificantClasses(element)

  if (classes.length === 0) return null

  // Try tag + single class
  for (const cls of classes) {
    const selector = `${tag}.${CSS.escape(cls)}`
    if (isUniqueSelector(selector)) {
      return selector
    }
  }

  // Try tag + two classes
  if (classes.length >= 2) {
    for (let i = 0; i < classes.length - 1; i++) {
      for (let j = i + 1; j < classes.length; j++) {
        const selector = `${tag}.${CSS.escape(classes[i])}.${CSS.escape(classes[j])}`
        if (isUniqueSelector(selector)) {
          return selector
        }
      }
    }
  }

  return null
}

/**
 * Generate a structural path selector as fallback
 */
function generateStructuralPath(element: HTMLElement): string {
  const path: string[] = []
  let current: HTMLElement | null = element
  let depth = 0
  const maxDepth = 5

  while (current && current !== document.body && depth < maxDepth) {
    let selector = current.tagName.toLowerCase()

    // Add ID if available
    if (current.id && isValidId(current.id)) {
      selector = `#${CSS.escape(current.id)}`
      path.unshift(selector)
      break // ID is unique enough
    }

    // Add significant class if available
    const classes = getSignificantClasses(current)
    if (classes.length > 0) {
      selector += `.${CSS.escape(classes[0])}`
    }

    // Add nth-child if needed for uniqueness
    const parent = current.parentElement
    if (parent) {
      const siblings = Array.from(parent.children).filter(
        (child) => child.tagName === current?.tagName,
      )
      if (siblings.length > 1) {
        const index = siblings.indexOf(current) + 1
        selector += `:nth-child(${index})`
      }
    }

    path.unshift(selector)
    current = current.parentElement
    depth++
  }

  const fullSelector = path.join(' > ')

  // Verify the selector works
  if (isUniqueSelector(fullSelector)) {
    return fullSelector
  }

  // If still not unique, add more specificity
  return `body ${fullSelector}`
}

/**
 * Get a text preview from an element (for display purposes)
 */
function getTextPreview(element: HTMLElement): string | null {
  // Get direct text content (not from children)
  const textNodes = Array.from(element.childNodes).filter(
    (node) => node.nodeType === Node.TEXT_NODE,
  )

  const directText = textNodes
    .map((node) => node.textContent?.trim())
    .filter(Boolean)
    .join(' ')

  if (directText && directText.length > 0) {
    return directText.length > 50 ? directText.substring(0, 50) + '...' : directText
  }

  // Fall back to full text content
  const fullText = element.textContent?.trim()
  if (fullText && fullText.length > 0) {
    return fullText.length > 50 ? fullText.substring(0, 50) + '...' : fullText
  }

  return null
}

/**
 * Validate if a selector still matches an element on the page
 */
export function validateSelector(selector: string): boolean {
  try {
    const element = document.querySelector(selector)
    return element !== null
  } catch {
    return false
  }
}

/**
 * Check if element exists on the page using selector
 */
export function elementExists(selector: string): boolean {
  return validateSelector(selector)
}
